/*
  ██╗██╗      ███████╗███╗   ███╗ █████╗ ██████╗ ████████╗      ██╗██╗  
 ██╔╝╚██╗     ██╔════╝████╗ ████║██╔══██╗██╔══██╗╚══██╔══╝     ██╔╝╚██╗ 
██╔╝  ╚██╗    ███████╗██╔████╔██║███████║██████╔╝   ██║       ██╔╝  ╚██╗
╚██╗  ██╔╝    ╚════██║██║╚██╔╝██║██╔══██║██╔══██╗   ██║       ╚██╗  ██╔╝
 ╚██╗██╔╝     ███████║██║ ╚═╝ ██║██║  ██║██║  ██║   ██║        ╚██╗██╔╝ 
  ╚═╝╚═╝      ╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝         ╚═╝╚═╝  
███████╗██╗ ██████╗ ███╗   ██╗ █████╗ ████████╗██╗   ██╗██████╗ ███████╗
██╔════╝██║██╔════╝ ████╗  ██║██╔══██╗╚══██╔══╝██║   ██║██╔══██╗██╔════╝
███████╗██║██║  ███╗██╔██╗ ██║███████║   ██║   ██║   ██║██████╔╝█████╗  
╚════██║██║██║   ██║██║╚██╗██║██╔══██║   ██║   ██║   ██║██╔══██╗██╔══╝  
███████║██║╚██████╔╝██║ ╚████║██║  ██║   ██║   ╚██████╔╝██║  ██║███████╗
╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝  ╚═╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚══════╝
*/

// DIE's signature file
// Author: DosX; Telegram: @DosX_Plus
// This smart analysis will help identify the presence of obfuscation through complex checks

// Please do not read the code out loud unless you have exorcism skills

function detect() {
    if (!PE.isNET()) return null; // Only .NET binaries supported...

    const isVbNet = PE.isNETStringPresent("Microsoft.VisualBasic");

    var options = "";

    var isEntryPointModified = false;
    if (!PE.isDll()) {
        if (isVbNet) {
            if (isAllNetReferencesMissing(
                    [
                        "Main",
                        "main",
                        "MAIN",
                        "MyApplication"
                    ]
                )) {
                isEntryPointModified = true;
            }
        } else if (isAllNetReferencesMissing(
                [
                    "Main",
                    "<Main>$" // For programs with top-level operators
                ]
            )) {
            isEntryPointModified = true;
        }
    }

    if (isEntryPointModified) options += "Modified EP";




    var isNativeEntryPointModified = false;
    if (!PE.isDll()) {
        if (!PE.is64()) {
            // FF2500????00: jmp dword ptr [ ... ]
            if (!PE.compareEP("FF 25 ?? ?? ?? 00")) {
                isNativeEntryPointModified = true;
            }
        } else { // AMD64
            if (PE.VAToOffset(PE.getAddressOfEntryPoint()) != 0x00) {
                isNativeEntryPointModified = true;
            }
        }
    }

    if (isNativeEntryPointModified) options += (options != "" ? " + " : "") + "Modified native EP";




    if (PE.findSignature(PE.getDosStubOffset(), PE.getDosStubSize(), "'This program cannot be run in DOS mode.'") == -1) {
        options += (options != "" ? " + " : "") + "Modified DOS";
    }




    const badChars = '_-=+~!@#$%^&*()"№;%:?*():;,/\\|\'`<>.0123456789'; // Very very bad!

    var strangeSections = false;

    if (PE.getNumberOfSections() > 6 || !PE.isSectionNamePresent(".text")) {
        strangeSections = true;
    } else {
        for (var i = 0; i != PE.getNumberOfSections(); i++) {
            var sectionName = PE.getSectionName(i);
            if (sectionName[0] != "." && sectionName.length < 3) { // Checks if the first char is "." and length more than 4
                strangeSections = true;
                break;
            }

            for (var x = 1; x < sectionName.length; x++) { // Reads all chars after "."
                for (var d = 0; d < badChars.length; d++) {
                    if (sectionName[x] == badChars[d]) {
                        strangeSections = true;
                        break;
                    }
                }
            }
        }
    }

    if (strangeSections) options += (options != "" ? " + " : "") + "Strange sections";




    const opCodes = new NetOpCodes();




    const intConfusionXorPattern = opCodes.ldc_i4 + opCodes.ldc_i4 + opCodes.xor + opCodes.ldc_i4;

    if (validateSignature(intConfusionXorPattern)) {
        if (validateSignature( // samples by: Inx Obfuscator
                intConfusionXorPattern +
                (opCodes.bne_un_s + opCodes.dc_i4_2 + opCodes.stloc_0 + opCodes.sizeof + opCodes.add)
            ) ||
            validateSignature( // samples by: MindLated, NetShield
                intConfusionXorPattern +
                (opCodes.bne_un + opCodes.ldc_i4 + opCodes.stloc + opCodes.sizeof + opCodes.add)
            ) ||
            validateSignature( // samples by: VavilonProtect
                intConfusionXorPattern +
                (opCodes.bne_un + opCodes.ldc_i4_2 + opCodes.stloc_s + opCodes.sizeof + opCodes.add)
            )
        ) { options += (options != "" ? " + " : "") + "Int Confusion"; }
    }




    if (
        isAllNetReferencesPresent(
            references = [
                "System.Reflection", // System.Reflection.dll
                "GetILGenerator", // MSIL: 'System.Reflection.Emit.DynamicMethod::GetILGenerator()'
                "BeginInvoke",
                "EndInvoke",
                "OpCode" // MSIL: 'System.Reflection.Emit.OpCode'
            ]
        ) &&
        (
            validateSignature("'Ldarg_0'") || // MSIL: 'System.Reflection.Emit.OpCodes.Ldarg_0'
            validateSignature("'CreateDelegate'") // MSIL: 'System.Delegate.CreateDelegate'
        ) && !isFrameworkComponent()
    ) { options += (options != "" ? " + " : "") + "Virtualization"; }




    // https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.suppressildasmattribute
    if (
        PE.isNETStringPresent("SuppressIldasmAttribute")
    ) { options += (options != "" ? " + " : "") + "Anti ILDASM"; }




    // Anti de4dot via inheritance
    if (
        validateSignature("'Form'??????00'Form'??????00'Form'??????00") || // samples by: NetShield
        PE.isNETStringPresent("Form0") // samples by: MindLated
    ) { options += (options != "" ? " + " : "") + "Anti de4dot"; }




    const debuggerObject = "Debugger", // MSIL: 'System.Diagnostics.Debugger' from System.Diagnostics.dll
        isAttached = "get_IsAttached", // MSIL: '*.Debugger::get_IsAttached()'
        isLogging = "IsLogging" // MSIL: '*.Debugger::IsLogging()'

    if (
        (( // .NET Functions
                PE.isNETStringPresent(debuggerObject) || PE.isNETUnicodeStringPresent(debuggerObject) // Check for 'Debugger'
            ) && (
                (PE.isNETStringPresent(isAttached) || PE.isNETUnicodeStringPresent(isAttached)) || // Check for 'get_IsAttached' property
                (PE.isNETStringPresent(isLogging) || PE.isNETUnicodeStringPresent(isLogging)) // Check for 'IsLogging' function
            ) ||
            ( // Native (WinAPI) functions
                PE.isNETStringPresent("CheckRemoteDebuggerPresent") || PE.isNETStringPresent("IsDebuggerPresent")
            )) && !isFrameworkComponent()
    ) { options += (options != "" ? " + " : "") + "Anti Debug"; }




    if (validateSignature( // samples by: MindLated
            opCodes.setStrict_2b(opCodes.ldftn, "?? ?? 00 0A") +
            opCodes.setStrict(opCodes.calli, "?? 00 00 11")
        ) ||
        validateSignature( // samples by: ArmDot, DarksProtector
            opCodes.idelem_i +
            opCodes.setStrict(opCodes.calli, "?? 00 00 11")
        )) { options += (options != "" ? " + " : "") + "Calli Invokes"; }




    if (validateSignature( // samples by: ConfuserEx
            opCodes.nop + opCodes.ldloc_0 + opCodes.ldc_i4 + opCodes.mul + opCodes.ldc_i4 + opCodes.xor + opCodes.br_s +
            opCodes.nop + opCodes.ldloc_0 + opCodes.ldc_i4 + opCodes.mul + opCodes.ldc_i4 + opCodes.xor + opCodes.br_s
        ) ||
        validateSignature( // samples by: .NET Reactor
            opCodes.ldsfld + opCodes.brfalse + opCodes.pop +
            opCodes.setStrict(opCodes.ldc_i4, "01 00 00 00") + // MSIL: 'ldc.4 1'
            opCodes.br + opCodes.nop
        ) ||
        validateSignature( // samples by: .NET Reactor (legacy~~)
            opCodes.stloc + opCodes.ldloc +
            "45 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 00 00" + // OPCODE: 'switch ...'
            opCodes.ldc_i4 + opCodes.br
        ) ||
        validateSignature( // samples by: MindLated, NetShield
            opCodes.setStrict(opCodes.ldc_i4, "00 00 00 00") + // MSIL: 'ldc.i4 0'
            opCodes.stloc + opCodes.br + opCodes.nop + opCodes.ldloc +
            opCodes.setStrict(opCodes.ldc_i4, "01 00 00 00") + // MSIL: 'ldc.i4 1'
            opCodes.ceq + opCodes.brfalse
        ) ||
        validateSignature( // samples by: Rose Obfuscator
            opCodes.setStrict(opCodes.ldc_i4, "00 00 00 00") + // MSIL: 'ldc.i4'
            opCodes.stloc + opCodes.br + opCodes.nop + opCodes.ldloc + opCodes.ldc_i4 + opCodes.ceq + opCodes.brfalse
        ) ||
        validateSignature( // samples by: Smart Assembly
            opCodes.ldc_i4 + opCodes.br + opCodes.ldloc_s + opCodes.ldc_i4_s + opCodes.ldc_i4_0 + opCodes.stelem_i1 + opCodes.ldc_i4 + opCodes.br
        )
    ) { options += (options != "" ? " + " : "") + "Ctrl Flow"; }




    const mathOpCodes = [
        opCodes.add, opCodes.mul,
        opCodes.div, opCodes.xor,
        opCodes.shr, opCodes.shl,
        opCodes.or, opCodes.not,
        opCodes.and
    ];

    var isMutationsPresent = false;

    for (var e = 0; e < mathOpCodes.length; e++) {

        // TODO: array with patterns

        const prefix = opCodes.ldc_i4 + opCodes.ldc_i4,
            postfix = opCodes.stloc;

        const pattern = prefix + mathOpCodes[e] + postfix;

        if (validateSignature(pattern)) {
            isMutationsPresent = true;
            break;
        }
    }

    if (isMutationsPresent) options += (options != "" ? " + " : "") + "Math mutations";




    if (validateSignature(opCodes.ldc_i4 + opCodes.not) && (
            validateSignature( // ~(-(~(-(~(-(~(-( num ))))))))
                opCodes.ldc_i4 +
                opCodes.not + opCodes.neg + opCodes.not + opCodes.neg +
                opCodes.not + opCodes.neg + opCodes.not + opCodes.neg
            ) ||
            validateSignature( // ~(~(-(-(~(~( num ))))))
                opCodes.ldc_i4 +
                opCodes.not + opCodes.not + opCodes.neg + opCodes.neg +
                opCodes.not + opCodes.not
            ) ||
            validateSignature( // ~(-(~(~(-(-( num ))))))
                opCodes.ldc_i4 +
                opCodes.not + opCodes.neg + opCodes.not + opCodes.not +
                opCodes.neg + opCodes.neg
            ) ||
            validateSignature( // ~(-(~(-(~(~( num ))))))
                opCodes.ldc_i4 +
                opCodes.not + opCodes.neg + opCodes.not + opCodes.neg +
                opCodes.not + opCodes.not
            )
        )) { options += (options != "" ? " + " : "") + "Math inversions"; }




    if (
        PE.isNETStringPresent("VirtualProtect") && ( // from 'kernel32.dll', WinAPI
            // Need to check
            isAllNetReferencesPresent( // samples by: ConfuserEx, SkiDzEX
                references = [
                    "System.Runtime.InteropServices", // System.Runtime.InteropServices.dll
                    "Marshal", // MSIL: '*.Marshal::GetHINSTANCE( ... )'
                    "GetHINSTANCE", // MSIL: '*.Marshal::GetHINSTANCE( ... )'
                    "IntPtr", // MSIL: 'System.IntPtr'
                    "op_Explicit" // MSIL: 'System.IntPtr::op_Explicit'
                ]
            ) ||
            isAllNetReferencesPresent( // samples by: Inx Obfuscator
                references = [
                    "System.Diagnostics", // System.Diagnostics
                    "memcpy", // from 'msvcrt.dll', WinAPI
                    "IntPtr", // MSIL: 'System.IntPtr'
                    "get_MainModule", // MSIL: '*.Process::get_MainModule()'
                    "get_BaseAddress" // MSIL: '*.ProcessModule::get_BaseAddress()'
                ]
            ) ||
            isAllNetReferencesPresent( // samples by: MindLated
                references = [
                    "System.Runtime.InteropServices", // System.Runtime.InteropServices.dll
                    "Marshal", // MSIL: '*.Marshal::GetHINSTANCE( ... )'
                    "GetHINSTANCE", // MSIL: '*.Marshal::GetHINSTANCE( ... )'
                    "IntPtr", // MSIL: 'System.IntPtr'
                    "CopyBlock",
                    "InitBlock"
                ]
            )
        )
    ) { options += (options != "" ? " + " : "") + "Anti Dump"; }




    const obfuscatorsAttributes = [
        "Xenocode.Client.Attributes.AssemblyAttributes.ProcessedByXenocode",
        "CryptoObfuscator.ProtectedWithCryptoObfuscatorAttribute",
        "SecureTeam.Attributes.ObfuscatedByAgileDotNetAttribute",
        "Xenocode.Client.Attributes.AssemblyAttributes",
        "SmartAssembly.Attributes.PoweredByAttribute",
        "ObfuscatedByAgileDotNetAttribute",
        "NineRays.Obfuscator.Evaluation",
        "ObfuscatedByCliSecureAttribute",
        "BabelObfuscatorAttribute",
        "AsStrongAsFuckAttribute",
        "Macrobject.Obfuscator",
        "DotfuscatorAttribute",
        "CodeWallTrialVersion",
        "ConfusedByAttribute",
        "ObfuscatedByGoliath",
        "NETSpider.Attribute",
        "NineRays.Obfuscator",
        "PoweredByAttribute", // Smart Assembly
        "BabelAttribute",
        "YanoAttribute",
        "EMyPID_8234_",
        "ZYXDNGuarder",
        "Sixxpack",
        "____KILL", // CodeVeil
        "Reactor",
    ];

    var isFakeSignaturesPresent = false;

    var signaturesCounter = 0;
    for (var t = 0; t < obfuscatorsAttributes.length; t++) {
        if (PE.isNETStringPresent(obfuscatorsAttributes[t]))
            signaturesCounter++;

        if (signaturesCounter > 1) {
            isFakeSignaturesPresent = true;
            break;
        }
    }

    if (isFakeSignaturesPresent) {
        options += (options != "" ? " + " : "") + "Fake signatures";
    } else {
        // "Watermark" is only possible in the absence of fake signatures
        if ((signaturesCounter == 1 ||
                validateSignature("'Obfuscated'") ||
                validateSignature("'obfuscated'") ||
                validateSignature("'ByAttribute'") ||
                validateSignature("'ObfuscatorAttribute'") ||
                PE.isNETStringPresent("ObfuscationAttribute")) && !isFrameworkComponent()) // System.Reflection.ObfuscationAttribute
        { options += (options != "" ? " + " : "") + "Watermark"; }
    }




    const protectorsLabelsToRemove = [ // Protectors with these names will be removed from results
        "Xenocode Postbuild",
        "Smart Assembly",
        "Dotfuscator",
        "Babel .NET",
        "Spices.Net",
        "DNGuard",
        "Goliath",
        "Yano"
    ];

    if (isFakeSignaturesPresent) {
        for (var d = 0; d < protectorsLabelsToRemove.length; d++) {
            _removeResult("protector", protectorsLabelsToRemove[d]);
        }
    }


    if (options != "") {
        _setResult("protection", "Obfuscation", "", PE.isVerbose() ? options : "");
    }

    return null; // Coming soon...

    if (PE.isHeuristicScan()) {
        options = "";

        const highEntropyValue = 7.2;

        // Coming soon...

        if (options != "") {
            _setResult("protection", "Obfuscation", "Heuristic", options);
        }
    }
}

function NetOpCodes() {
    this.add = "58"; // MSIL: 'add'
    this.sub = "59"; // MSIL: 'sub'
    this.mul = "5A"; // MSIL: 'mul'
    this.and = "5F"; // MSIL: 'and'
    this.bne_un = "40????????"; // MSIL: 'bne.un'
    this.bne_un_s = "3309"; // MSIL: 'bne.un.s'
    this.br = "38????????"; // MSIL: 'br'
    this.br_s = "2B??"; // MSIL: 'br.s'
    this.brfalse = "39????????"; // MSIL: 'brfalse'
    this.call = "28????????"; // MSIL: 'call'
    this.calli = "29????????"; // MSIL: 'calli'
    this.ceq = "FE01"; // MSIL: 'ceq'
    this.div = "5B"; // MSIL: 'div'
    this.idelem_i = "97"; // MSIL: 'idelem.i'
    this.ldc_i4 = "20????????"; // MSIL: 'ldc.i4'
    this.ldc_i4_0 = "16"; // MSIL: 'ldc.i4.0'
    this.ldc_i4_1 = "1A"; // MSIL: 'ldc.i4.1'
    this.ldc_i4_2 = "18"; // MSIL: 'ldc.i4.2'
    this.ldc_i4_s = "1F??"; // MSIL: 'ldc.i4.s'
    this.ldftn = "FE06????????"; // MSIL: 'ldftn'
    this.ldloc = "FE??????"; // MSIL: 'ldloc'
    this.ldloc_0 = "06"; // MSIL: 'ldloc.0'
    this.ldloc_1 = "07"; // MSIL: 'ldloc.1'
    this.ldloc_2 = "08"; // MSIL: 'ldloc.2'
    this.ldloc_3 = "09"; // MSIL: 'ldloc.3'
    this.ldloc_s = "11??"; // MSIL: 'ldloc.s'
    this.ldsfld = "7E????????"; // MSIL: 'ldsfld'
    this.ldstr = "72????????"; // MSIL: 'ldstr'
    this.nop = "00"; // MSIL: 'nop'
    this.not = "66"; // MSIL: 'not'
    this.neg = "65"; // MSIL: 'neg'
    this.or = "60"; // MSIL: 'or'
    this.pop = "26"; // MSIL: 'pop'
    this.ret = "2A"; // MSIL: 'ret'
    this.shl = "62"; // MSIL: 'shl'
    this.shr = "63"; // MSIL: 'shr'
    this.sizeof = "FE1C????????"; // MSIL: 'sizeof'
    this.stloc = "FE0E????"; // MSIL: 'stloc'
    this.stloc_0 = "0A"; // MSIL: 'stloc.0'
    this.stloc_1 = "0B"; // MSIL: 'stloc.1'
    this.stloc_2 = "0C"; // MSIL: 'stloc.2'
    this.stloc_3 = "0D"; // MSIL: 'stloc.3'
    this.stloc_s = "1303"; // MSIL: 'stloc.s'
    this.xor = "61"; // MSIL: 'xor'
    this.stelem_i1 = "9C"; // MSIL: 'stelem.i1'


    // setStrict sets the strict value of the opcode for substitution
    // btw I like what I do
    this.setStrict = function(opCodeHex, value) {
        return opCodeHex.substr(0x00, 0x02) + value;
    }

    // setStrict for opcodes that weigh 2 bytes
    this.setStrict_2b = function(opCodeHex, value) {
        return opCodeHex.substr(0x00, 0x04) + value;
    }
}

function isFrameworkComponent() {
    return PE.isDll() && PE.compare("........00020200", PE.getOverlayOffset()) && PE.findSignature(PE.getOverlayOffset(), 300, "'Microsoft Corporation'") != -1
}

function validateSignature(sign) {
    return validateSignatureRef(sign) != -1;
}

function validateSignatureRef(sign) {
    return PE.findSignature(0x00, PE.getSize() - PE.getOverlaySize(), sign);
}

function isAllNetReferencesMissing(references) {
    for (var i = 0; i < references.length; i++) {
        const ref = references[i];
        if (PE.isNETStringPresent(ref)) {
            return false;
        }
    }

    return true;
}


function isAllNetReferencesPresent(references) {
    for (var i = 0; i < references.length; i++) {
        const ref = references[i];
        if (!PE.isNETStringPresent(ref)) {
            return false;
        }
    }

    return true;
}


// Every time I start writing bad code I get hit with my head on the keybofewuihdsowefjfqodgsa79dowqhdsioefurogrwhuoguethuhofrwyi